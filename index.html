<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Go</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>

<script src="../jlib/gfx.js"></script>

<script>

// --------------------------------------------------------------------
// Globals
var _game = null;

var config = {
    grid_thick             : 1,
    stone_frac             : 1,

    color_active           : "80c000",
    color_bg               : "103020",
    color_black            : "101010",
    color_board            : "d19d00",
    color_inactive         : "c04000",
    color_line             : "000000",
    color_panel_bg         : "203050",
    color_panel_side_bg    : "80c000",
    color_white            : "f0f0f0",
};

// --------------------------------------------------------------------
class ActiveRect {
    constructor(x, y, w, h, bg_color, text = "", xb = 0, yb = 0, border_color = null) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.xb = xb;
        this.yb = yb;
        this.set_color(bg_color, border_color);
        this.set_text(text);
    }
    set_color(bg_color, border_color = null) {
        this.bg_color = bg_color;
        this.border_color = border_color;
    }
    set_text(text) {
        this.text = text;
    }
    is_in(x, y) {
        return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
    }
    draw(gfx) {
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, this.xb, this.yb, this.bg_color, this.border_color);
        if (this.text != null)
            gfx.draw_centered_text(this.x, this.y, this.w, this.text, config.color_black);
    }
};

// --------------------------------------------------------------------
class Stone {
    constructor(x, y, side) {
        this.side = side;
        this.x = x;
        this.y = y;
    }
    draw(gfx, sz) {
        const xm = sz.xm + sz.m;
        const ym = sz.ym + sz.m;
        const x = xm + this.x * sz.sw;
        const y = ym + this.y * sz.sh;
        const r = sz.sh * config.stone_frac / 2;
        Stone.draw_at(gfx, x, y, r, this.side);
    }
    static draw_at(gfx, x, y, r, side) {
        const color = Stone.color(side);
        const ocolor = Stone.color(1 - side);
        gfx.draw_circle(x, y, r, ocolor);
        gfx.draw_circle(x, y, r-1, color);
    }
    static color(side) {
        return (side == 0) ? config.color_black : config.color_white;
    }
};

// --------------------------------------------------------------------
class Board {
    constructor(w, h) {
        this.stones = [];
        this.curr_side = 0;
        this.show_terr = false;
        this.set_size(w, h);
    }
    set_size(w, h) {
        this.del_stones();
        this.w = w;
        this.h = h;
    }
    add_stone(x, y, side) {
        this.stones.push(new Stone(x, y, side));
        for (const n of this.#neighbors(x, y)) {
            const group = this.#dead_group(n.x, n.y);
            if (group != null)
                this.#del_group(group);
        }
    }
    del_stone(sx) {
        this.stones.splice(sx, 1);
    }
    del_stones() {
        this.stones.splice(0);
    }
    num_stones() {
        return this.stones.length;
    }
    #del_group(group) {
        const ss = [];
        for (const stone of group) {
            const sx = this.#get_stone(stone.x, stone.y);
            ss.push(sx);
        }
        ss.sort(function(a,b) { return b-a; });
        for (let i = 0; i < ss.length; ++i)
            this.del_stone(ss[i]);
    }
    #add_dead(list, x, y) {
        const sx = this.#get_stone(x, y);
        if (sx < 0) return null;
        list.push(this.stones[sx]);
        const side = this.stones[sx].side;
        for (const n of this.#neighbors(x, y)) {
            const tsx = this.#get_stone(n.x, n.y);
            if (tsx < 0) // found a liberty
                return null;
            if (this.stones[tsx].side == side && Board.#get_list_stone(list, n.x, n.y) < 0) {
                if (this.#add_dead(list, n.x, n.y) == null)
                    return null;
            }
        }
        return list;
    }
    #dead_group(x, y) {
        const group = [];
        return this.#add_dead(group, x, y);
    }
    static #get_list_stone(list, x, y) {
        for (let sx = 0; sx < list.length; ++sx) {
            if (list[sx].x == x && list[sx].y == y)
                return sx;
        }
        return -1;
    }
    #get_stone(x, y) {
        return Board.#get_list_stone(this.stones, x, y);
    }
    #neighbors(x, y) {
        const list = [];
        for (const d of [[-1,0],[+1,0],[0,-1],[0,+1]]) {
            const tx = x + d[0];
            const ty = y + d[1];
            if (tx >= 0 && tx < this.w && ty >= 0 && ty < this.h)
                list.push({x:tx, y:ty});
        }
        return list;
    }
    draw(gfx) {
        const sz = this.size_up(gfx);
        // Draw board.
        gfx.draw_rect(sz.xm, sz.ym, sz.bs, sz.bs, config.color_board);
        // Draw grid.
        const xm = sz.xm + sz.m;
        const ym = sz.ym + sz.m;
        for (let xn = 0; xn < this.w; ++xn) {
            gfx.draw_rect(xm + sz.sw * xn, ym, config.grid_thick, sz.fld, config.color_line);
        }
        for (let yn = 0; yn < this.h; ++yn) {
            gfx.draw_rect(xm, ym + sz.sh * yn, sz.fld, config.grid_thick, config.color_line);
        }
        // Draw stars.
        const se = (this.w < 11 || this.h < 11) ? 2 : 3;
        const w2 = (this.w % 2) ? Math.floor(this.w / 2) : 0;
        const h2 = (this.h % 2) ? Math.floor(this.h / 2) : 0;
        this.#draw_star(gfx, sz, se, se);
        this.#draw_star(gfx, sz, se, this.h - se - 1);
        this.#draw_star(gfx, sz, this.w - se - 1, se);
        this.#draw_star(gfx, sz, this.w - se - 1, this.h - se - 1);
        if (w2 && h2) { // center of board
            this.#draw_star(gfx, sz, w2, h2);
        }
        if (w2 && this.w > 13) {
            this.#draw_star(gfx, sz, w2, se);
            this.#draw_star(gfx, sz, w2, this.h - se - 1);
        }
        if (h2 && this.h > 13) {
            this.#draw_star(gfx, sz, se, h2);
            this.#draw_star(gfx, sz, this.w - se - 1, h2);
        }
        // Draw stones.
        for (const stone of this.stones) {
            stone.draw(gfx, sz);
        }
    }
    #draw_star(gfx, sz, x, y) {
        gfx.draw_circle(sz.xm + sz.m + sz.sw * x, sz.ym + sz.m + sz.sh * y, sz.sr, config.color_line);
    }
    mouse(gfx, bx, by) {
        const sz = this.size_up(gfx);
        const xm = sz.xm + sz.m;
        const ym = sz.ym + sz.m;
        if (bx >= xm && bx < xm + sz.bs || by >= ym && by < ym + sz.bs) {
            const x = Math.floor((bx - xm + (sz.sw/2)) / sz.sw);
            const y = Math.floor((by - ym + (sz.sh/2)) / sz.sh);
            if (x >= 0 && x < this.w && y >= 0 && y < this.h) {
                const sx = this.#get_stone(x, y);
                if (sx < 0) {
                    this.add_stone(x, y, this.curr_side);
                    this.curr_side = 1 - this.curr_side;
                } else {
                    this.del_stone(sx);
                }
                return true;
            }
        }
        return false;
    }
    size_up(gfx) {
        const cw = gfx.ctx.canvas.width;
        const ch = gfx.ctx.canvas.height;
        let r = {};
        if (cw < ch) {
            r.xm = cw * .05;
            r.bs = cw - 2*r.xm;
            r.ym = r.xm;
        } else {
            r.ym = ch * .05;
            r.bs = ch - 2*r.ym;
            r.xm = r.ym;
        }
        r.sw = r.bs / this.w;
        r.sh = r.bs / this.h;
        r.m = Math.min(r.sw/2, r.sh/2);
        r.fld = r.bs - 2*r.m;
        r.sr = r.sh * .10; ///
        return r;
    }
};

// --------------------------------------------------------------------
class Panel {
    constructor(board) {
        this.board = board;
    }
    draw(gfx) {
        const side = this.board.curr_side;
        const sz = this.size_up(gfx);
        sz.panel.draw(gfx);

        const sm = 8;
        const sr = sz.side.h * .4;
        const sx = sz.side.x + sr * 1.1;
        const sy = sz.side.y + sz.side.h/2;
        sz.side.draw(gfx);
        Stone.draw_at(gfx, sx, sy, sr, this.board.curr_side);
        if (this.board.show_terr)
            sz.terr.set_color(config.color_active);
        sz.terr.draw(gfx);
        gfx.draw_text(sz.side.x + 3*sr, sz.side.y + (sz.side.h - gfx.font_height) / 2,
            (this.board.curr_side == 0) ? "BLACK" : "WHITE", config.color_black);
        if (this.board.w == 9 && this.board.h == 9)
            sz.bd9.set_color(config.color_active);
        else if (this.board.w == 13 && this.board.h == 13)
            sz.bd13.set_color(config.color_active);
        else if (this.board.w == 19 && this.board.h == 19)
            sz.bd19.set_color(config.color_active);
        sz.bd9.draw(gfx);
        sz.bd13.draw(gfx);
        sz.bd19.draw(gfx);
    }
    mouse(gfx, x, y) {
        const sz = this.size_up(gfx);
        if (sz.side.is_in(x, y)) {
            this.board.curr_side = 1 - this.board.curr_side;
            return true;
        }
        if (sz.terr.is_in(x, y)) {
            this.board.show_terr = !this.board.show_terr;
            return true;
        }
        if (sz.bd9.is_in(x, y)) {
            this.board.set_size(9, 9);
            return true;
        }
        if (sz.bd13.is_in(x, y)) {
            this.board.set_size(13, 13);
            return true;
        }
        if (sz.bd19.is_in(x, y)) {
            this.board.set_size(19, 19);
            return true;
        }
        return false;
    }
    size_up(gfx) {
        const cw = gfx.ctx.canvas.width;
        const ch = gfx.ctx.canvas.height;
        const bsz = this.board.size_up(gfx);
        let r = {};
        let x,y,w,h;
        if (cw < ch) {
            w = cw * .7;
            h = .95*ch - bsz.ym - bsz.bs - 20;
            x = (cw - w) / 2;
            y = bsz.ym + bsz.bs + 10; ///
        } else {
            w = .95*cw - bsz.xm - bsz.bs;
            h = bsz.bs;
            x = bsz.xm + bsz.bs + 10; ///
            y = bsz.ym;
        }
        const vsp = 8;
        const hsp = 12;
        const bh = 42;
        r.panel = new ActiveRect(x, y, w, h, config.color_panel_bg);
        r.side = new ActiveRect(x + hsp, y + vsp, 150, bh, config.color_panel_side_bg);
        r.terr = new ActiveRect(x + hsp, r.side.y + r.side.h + vsp, 200, bh, config.color_inactive, "Territory");
        const bdy = r.terr.y + r.terr.h + vsp;
        const bdw = 80;
        r.bd9 = new ActiveRect(x + hsp, bdy, bdw, bh, config.color_inactive, "9x9");
        r.bd13 = new ActiveRect(r.bd9.x + r.bd9.w + hsp, bdy, bdw, bh, config.color_inactive, "13x13");
        r.bd19 = new ActiveRect(r.bd13.x + r.bd13.w + hsp, bdy, bdw, bh, config.color_inactive, "19x19");
        return r;
    }
};

// --------------------------------------------------------------------
class Game {
    constructor(gfx, w, h) {
        this.gfx = gfx;
        this.board = new Board(w, h);
        this.panel = new Panel(this.board);
    }
    resize() {
        this.gfx.set_font_size(canvas.height*.040);
        this.draw();
    }
    draw() {
        this.gfx.clear(config.color_bg);
        this.board.draw(this.gfx);
        this.panel.draw(this.gfx);
    }
    event_mouse(event, x, y) {
        if (event == Game.MOUSE_DOWN) {
            if (this.board.mouse(this.gfx, x, y) || this.panel.mouse(this.gfx, x, y))
                this.draw();
        }
    }

    static _event_mousedown(e) { if (_game != null) _game.event_mouse(Game.MOUSE_DOWN, e.offsetX, e.offsetY); }
    static _event_mouseup(e) { if (_game != null) _game.event_mouse(Game.MOUSE_UP, e.offsetX, e.offsetY); }
    static _event_mousemove(e) { if (_game != null) _game.event_mouse(Game.MOUSE_MOVE, e.offsetX, e.offsetY); }

    static MOUSE_DOWN = 0;
    static MOUSE_UP   = 1;
    static MOUSE_MOVE = 2;
}; // class Game

// --------------------------------------------------------------------

function canvas_size(name, width, height) {
    const canvas = el(name);
    canvas.width = width;
    canvas.height = height;
    return canvas;
}

function canvas_to_window() {
    const s = 20;
    return canvas_size("canvas", window.innerWidth - s, window.innerHeight - s);
}

function canvas_resize() {
    canvas_to_window();
    if (_game != null) _game.resize();
}

function main() {
    munge_config();
    const canvas = canvas_to_window();
    const gfx = new Graphics(canvas.getContext("2d"), canvas.height*.040);
    _game = new Game(gfx, 19, 19);
    document.addEventListener('mousedown', Game._event_mousedown);
    document.addEventListener('mouseup', Game._event_mouseup);
    document.addEventListener('mousemove', Game._event_mousemove);
    window.addEventListener('resize', canvas_resize, false);
    _game.draw();
}

</script>
</body>
</html>
