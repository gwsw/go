<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Go</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>

<script src="../jlib/gfx.js"></script>

<script>

// --------------------------------------------------------------------
// Globals
var _game = null;

var config = {
    line_thick             : 1,
    stone_frac             : .5,

    color_bg               : "103020",
    color_black            : "101010",
    color_board            : "d19d00",
    color_line             : "000000",
    color_panel_bg         : "203050",
    color_panel_side_bg    : "a0a000",
    color_white            : "f0f0f0",
};

// --------------------------------------------------------------------
class Stone {
    constructor(x, y, side) {
        this.side = side;
        this.x = x;
        this.y = y;
    }
    draw(gfx, sz) {
        const xm = sz.xm + sz.m;
        const ym = sz.ym + sz.m;
        const x = xm + this.x * sz.sw;
        const y = ym + this.y * sz.sh;
        const r = sz.sh * config.stone_frac;
        Stone.draw_at(gfx, x, y, r, this.side);
    }
    static draw_at(gfx, x, y, r, side) {
        const color = Stone.color(side);
        const ocolor = Stone.color(1 - side);
        gfx.draw_circle(x, y, r, ocolor);
        gfx.draw_circle(x, y, r-1, color);
    }
    static color(side) {
        return (side == 0) ? config.color_black : config.color_white;
    }
};

// --------------------------------------------------------------------
class Board {
    constructor(w, h) {
        this.w = w;
        this.h = h;
        this.stones = [];
        this.curr_side = 0;
    }
    add_stone(x, y, side) {
        this.stones.push(new Stone(x, y, side));
    }
    draw(gfx) {
        const sz = this.size_up(gfx);
        gfx.draw_rect(sz.xm, sz.ym, sz.bs, sz.bs, config.color_board);

        const xm = sz.xm + sz.m;
        const ym = sz.ym + sz.m;
        for (let xn = 0; xn <= this.w; ++xn) {
            gfx.draw_rect(xm + sz.sw * xn, ym, config.line_thick, sz.fld, config.color_line);
        }
        for (let yn = 0; yn <= this.h; ++yn) {
            gfx.draw_rect(xm, ym + sz.sh * yn, sz.fld, config.line_thick, config.color_line);
        }
        const star_edge = 3;
        const xstep = Math.floor((this.w + 1) / 2) - star_edge;
        const ystep = Math.floor((this.h + 1) / 2) - star_edge;
        for (let xstar = star_edge; xstar <= this.w; xstar += xstep) {
            for (let ystar = star_edge; ystar <= this.h; ystar += ystep) {
                gfx.draw_circle(xm + sz.sw * xstar, ym + sz.sh * ystar, sz.sr, config.color_line);
            }
        }

        for (const stone of this.stones) {
            stone.draw(gfx, sz);
        }
    }
    mouse(gfx, bx, by) {
        const sz = this.size_up(gfx);
        const xm = sz.xm + sz.m;
        const ym = sz.ym + sz.m;
        if (bx >= xm && bx < xm + sz.bs || by >= ym && by < ym + sz.bs) {
            const x = Math.floor((bx - xm + (sz.sw/2)) / sz.sw);
            const y = Math.floor((by - ym + (sz.sh/2)) / sz.sh);
            if (x >= 0 && x <= this.w && y >= 0 && y <= this.h) {
                const stone = null;
                ///const stone = this.get_stone(x, y);
                if (stone == null) {
                    this.add_stone(x, y, this.curr_side);
                    this.curr_side = 1 - this.curr_side;
                } else {
                    this.del_stone(stone);
                }
                return true;
            }
        }
        return false;
    }
    size_up(gfx) {
        const cw = gfx.ctx.canvas.width;
        const ch = gfx.ctx.canvas.height;
        let r = {};
        if (cw < ch) {
            r.xm = cw * .05;
            r.bs = cw - 2*r.xm;
            r.ym = r.xm;
        } else {
            r.ym = ch * .05;
            r.bs = ch - 2*r.ym;
            r.xm = r.ym;
        }
        r.m   = r.bs * .04;
        r.fld = r.bs - 2*r.m;
        r.sw  = r.fld / this.w;
        r.sh  = r.fld / this.h;
        r.sr = r.sh * .10; ///
        return r;
    }

};

// --------------------------------------------------------------------
class Panel {
    constructor(board) {
        this.board = board;
    }
    draw(gfx) {
        const side = this.board.curr_side;
        const sz = this.size_up(gfx);
        gfx.draw_rect(sz.x, sz.y, sz.w, sz.h, config.color_panel_bg);

        const sm = 8;
        const sr = sz.side_h * .4;
        const sx = sz.side_x + sr * 1.1;
        const sy = sz.side_y + sz.side_h/2;
        gfx.draw_rect(sz.side_x, sz.side_y, sz.side_w, sz.side_h, config.color_panel_side_bg);
        Stone.draw_at(gfx, sx, sy, sr, this.board.curr_side);
        gfx.draw_text(sz.side_x + 2*sr, sz.side_y, (this.board.curr_side == 0) ? "BLACK" : "WHITE", config.color_black);
    }
    mouse(gfx, x, y) {
        const sz = this.size_up(gfx);
        if (x >= sz.side_x && x < sz.side_x + sz.side_w &&
            y >= sz.side_y && y < sz.side_y + sz.side_h) {
            this.board.curr_side = 1 - this.board.curr_side;
            return true;
        }
        return false;
    }
    size_up(gfx) {
        const cw = gfx.ctx.canvas.width;
        const ch = gfx.ctx.canvas.height;
        const bsz = this.board.size_up(gfx);
        let r = {};
        if (cw < ch) {
            r.w = cw * .7;
            r.h = .95*ch - bsz.ym - bsz.bs - 20;
            r.x = (cw - r.w) / 2;
            r.y = bsz.ym + bsz.m + bsz.bs + 10; ///
        } else {
            r.w = .95*cw - bsz.xm - bsz.bs;
            r.h = bsz.bs;
            r.x = bsz.xm + bsz.m + bsz.bs + 10; ///
            r.y = bsz.ym;
        }
        r.side_x = r.x + 10; ///
        r.side_y = r.y + 10; ///
        r.side_w = 150;  ////
        r.side_h = 42; ////
        return r;
    }
};

// --------------------------------------------------------------------
class Game {
    constructor(gfx, w, h) {
        this.gfx = gfx;
        this.board = new Board(w, h);
        this.panel = new Panel(this.board);
        this.playing = true;
        this.paused = false;
        this.pause_dur = 0;
    }
    resize() {
        this.draw();
    }
    pause(paused) {
        this.paused = paused;
        if (this.paused) {
            this.pause_start = now();
        } else { // unpause
            this.pause_dur += now() - this.pause_start;
        }
        this.draw();
    }
    draw() {
        this.gfx.clear(config.color_bg);
        this.board.draw(this.gfx);
        this.panel.draw(this.gfx);
    }
    event_keystroke(key, down) {
        if (!down) return;
        if (this.paused && key != 'p' && key != 'h' && key != '?') return;
        switch (key) {
        case 'p':
            this.pause(!this.paused);
            break;
        case 'ArrowDown':
        case 'ArrowUp':
        case 'ArrowRight':
        case 'ArrowLeft':
            break;
        }
    }
    event_mouse(event, x, y) {
        if (event == Game.MOUSE_DOWN) {
            if (this.board.mouse(this.gfx, x, y) || this.panel.mouse(this.gfx, x, y))
                this.draw();
        }
    }

    static _event_keydown(e) { if (_game != null) _game.event_keystroke(e.key, true); }
    static _event_keyup(e) { if (_game != null) _game.event_keystroke(e.key, false); }
    static _event_mousedown(e) { if (_game != null) _game.event_mouse(Game.MOUSE_DOWN, e.offsetX, e.offsetY); }
    static _event_mouseup(e) { if (_game != null) _game.event_mouse(Game.MOUSE_UP, e.offsetX, e.offsetY); }
    static _event_mousemove(e) { if (_game != null) _game.event_mouse(Game.MOUSE_MOVE, e.offsetX, e.offsetY); }

    static MOUSE_DOWN = 0;
    static MOUSE_UP   = 1;
    static MOUSE_MOVE = 2;
}; // class Game

// --------------------------------------------------------------------

function canvas_size(name, width, height) {
    const canvas = el(name);
    canvas.width = width;
    canvas.height = height;
    return canvas;
}

function canvas_to_window() {
    const s = 20;
    return canvas_size("canvas", window.innerWidth - s, window.innerHeight - s);
}

function canvas_resize() {
    canvas_to_window();
    if (_game != null) _game.resize();
}

function main() {
    munge_config();
    const canvas = canvas_to_window();
    const gfx = new Graphics(canvas.getContext("2d"), canvas.height*.040);
    _game = new Game(gfx, 19, 19);
    document.addEventListener('keyup', Game._event_keyup);
    document.addEventListener('keydown', Game._event_keydown);
    document.addEventListener('mousedown', Game._event_mousedown);
    document.addEventListener('mouseup', Game._event_mouseup);
    document.addEventListener('mousemove', Game._event_mousemove);
    window.addEventListener('resize', canvas_resize, false);
    _game.draw();
}

</script>
</body>
</html>
